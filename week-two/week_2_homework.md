# Week 2 Homework

题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

  ```
  堆（Heap）：JVM启动时创建，用于存放对象实例、数组和运行时常量的内存分配，也是垃圾回收的主要内存区域。当堆中没有足够内存来创建对象时，会抛出OOM（OutOfMemoryError）异常。
  JVM对堆进行了分代管理，分为新生代（Young Generation）和老年代（Old Generation）。
  
  虚拟机栈（Java VM Stack）：虚拟机栈是用于存储和管理Java方法执行过程中的内存模型。每个方法调用和执行都会创建一个栈帧（Stack Frame）被称为当前栈帧，并且进行入栈和出栈。栈帧存储了方法的局部变量表（Local Variable Table）、操作数栈（Operand Stack）、动态连接（Dynamic Linking）和返回地址（Return Address）等信息。线程请求的栈深度大于-Xss虚拟机深度时，会抛出StackOverflowError异常。
  栈是运行时的单位，堆是存储的单位。
  
  本地方法栈（Native Method Stack）：用于储存和管理本地方法（Native Method）的调用和执行。本地方法是指非Java语言编写的方法，因此可以理解为一个本地方法（Native Method）就是一个Java调用非Java代码的接口。
  
  方法区（Method Area）：JVM启动时创建，用于存储编译器已经编译后的类信息，运行时常量池，类型信息，字段信息，方法信息，类变量，静态变量，成员变量，方法数据，构造方法，字节码指令等。JDK7之前，被称为永久代（PermGen）。JDK8及之后，元空间（Metaspace）取代了永久代。永久代使用的是JVM进程使用的内存，而元空间使用的内存区域是物理内存区域。元空间改成只存储类的元信息，把静态变量和运行时常量池挪到了堆中。
  
  运行时常量池（字符串常量池）（Runtime Constant Pool）：为了提高匹配速度，加快数据查找的速度，JVM启动时创建的一个全局存储字符串的常量池，存放的是字符串常量值。实现方式为StringTable，类似于哈希表的key value查找，根据字符串的hashcode找到其对应的entry并返回引用。
  
  直接内存：为了提高I/O性能，提高读写速度，绕过Java虚拟机的内存空间。是直接向本地IO进行申请的内存，而不受虚拟机的管理。
  ```

- 为什么堆内存要分年轻代和老年代？

  ```
  主要目的是为了使JVM可以更好的管理和分配堆内存中的对象，提高程序的性能和效率，降低垃圾收集成本。
  
  新生代约占堆内存的1/5，被划分为3个区域，Eden、Survivor From 和 Survivor To，其比例为8：1：1。新创建的对象会放在新生代的Eden里，当Eden区被占满时，会触发一次新生代的垃圾回收（MinorGC）。此时存活的对象会被记录其年龄并放到SurvivorFrom区，当Eden再次被占满触发垃圾回收（MinorGC）时，会扫描Eden和From区并进行垃圾回收（MinorGC），并将存活的对象放入SurvivorTo区。最后From区和To区互换，即谁空谁是To。如此互换15次（默认的MaxTenuringThreshold）后仍然存活的对象进入老年代。
  
  而老年代是用来存放生命周期较长的对象的，约占堆内存的4/5。当一个对象在新生代经历过多次垃圾回收（MinorGC）时仍然存活，或对象由于过大（默认的PretenureSizeThreshold，1M）而无法放入新生代时，就会被放入老年代。而当老年代区被占满或由于对象过大放入不进新生代而放入老年代时，也同样会触发老年代的垃圾回收（MajorGC）。
  ```

题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程

  ```
  当执行new指令的时候，JVM会先检查该对象的类是否已经被加载，如果没有，则会先加载该类的字节码对象到内存中，并为该对象分配一块内存空间。初始化内存空间的分配方式有两种：指针碰撞和空闲列表。之后为对象的属性进行初始化，设置元数据哈希码GC分代年龄等信息。
  ```

- 解释一个对象的内存分配

  ```
  初始化内存空间的分配方式有两种：指针碰撞和空闲列表。指针碰撞多以新生代为主，内存地址是连续的。空闲列表多以老年代为主，内存地址不连续，回收时采用标记整理算法。当分配内存遇到分配冲突时，会先从本地线程分配缓存（TLAB）（Thread Local Allocation Buffer）里分配，如果不能被分配到，则再使用CAS（Compare and Swap）乐观锁。
  ```

- 解释一个对象的销毁过程

  ```
  对象销毁是由垃圾回收机制完成的，使用引用计数法，根搜索算法等找到标记并回收内存中不再被引用的对象。如果一个对象没有任何变量指向它，或所属的引用链不可达，则会被清除。新生代通常采用复制算法，老年代使用标记清除、标记整理算法来实现垃圾回收。
  ```

- 对象的 2 种访问方式是什么？

  ```
  句柄和直接指针。
  句柄为从句柄池中找到对象对应实例数据的指针，从而找到实例池中对象的数据。优点为比较文档，可以直接修改句柄中的地址来实现对象的移动和修改。
  直接指针是直接在本地变量表中找到对象对应的指针，好处为访问速度快，不需要再从实例池中再进行一次查找，节省指针的开销。
  ```

- 为什么需要内存担保？

  ```
  在当新生代把对象转移到老年代时的机制，被称为内存担保。是为了避免在新生代分配内存时发生内存不足的情况，保证新生代的内存分配不会失败。
  ```

题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

```
垃圾收集算法有三种：
标记清除算法（Mark-Sweep），
复制算法（Copying），
标记整理算法（Mark-Compact）。

标记清除算法分为两个步骤，首先标记出所有需要回收的对象，然后清除掉这些对象所占的空间。缺点是效率不够高，且会产生大量不连续的内存碎片。

复制算法是将内存分为两块相等的区域，每次都只使用其中一块。当一块被占满时，把还存活的对象复制到另一块上，然后清除掉原来的区域。此算法比较适用于年轻代。优点是效率会大幅度提升且不会内存空间碎片化，缺点是内存利用率很低存在空间浪费。

标记整理算法是对标记清除算法的改进，在标记出需要回收的对象后将所有的存活对象向一端移动。优点是没有空间浪费，没有内存碎片化的问题。缺点是移动对象开销很大，性能很低。比较适用于老年代。

垃圾回收器有8种，分别用于不同分代的垃圾回收。
新生代回收器：Serial、ParNew、Parallel Scavenge
老年代回收器：Serial Old、Parallel Old、CMS
整堆回收器：G1、ZGC
```

- ParallelScavenge 收集器

  ```
  新生代使用并行收集器，采用复制算法。老年代使用串行收集器，使用标记整理算法。主要关注系统吞吐量，即 运行用户代码时间/(运行用户代码时间+运行垃圾收集时间) 越趋近1意味着吞吐量越好越大，垃圾收集需要暂停用户线程。
  ```

- ParallelOld 收集器

  ```
  老年代的并行收集器，ParallelScavenge的老年代版本。同样吞吐量优先，使用多线程进行标记整理算法。垃圾收集同样需要暂停用户线程，对cpu敏感。
  ```

- ParNew 收集器

  ```
  Serial的多线程版本，单核cpu不建议使用，使用复制算法。响应优先，即减少用户线程停顿时间。需要指定垃圾收集的线程数。新生代使用并行ParNew，老年代使用串行SerialOld。
  ```

- CMS（Concurrent Mark Sweep GC）收集器

  ```
  主要用在老年代并发收集器，使用标记清除算法，同样响应优先。低延时，减少STW对用户的影响。用户线程与收集线程一起执行，cpu敏感。
  ```

- G1（Garbage First）收集器

  ```
  全新的面向服务端应用的全功能型的垃圾收集器。吞吐量和低延时皆可行的整堆垃圾收集器。适用于新生代和老年代。全局使用多线程进行标记整理算法，将内存空间划分为多个小块，称为区域（Region），在逻辑上有Eden、Survivor、Old、Humongous（当对象的容量超过Region的50%，则被认为是巨型对象）。局部采用复制算法收集。
  ```

  
